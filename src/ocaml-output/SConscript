import sys
import os
import subprocess
import re
import time
import datetime
import tempfile
import SCons

Import('My_env')
env = My_env.Clone()  # ensure changes here don't have impact on other SConscripts

# --------------------------------------------------------------------
conf = Configure(env)
if sys.platform == 'win32' or sys.platform == 'cygwin':  # Windows 32-bit or 64-bit
  # Windows Python doesn't know how to handle menhir, which is a PE file with no
  # extension.
  menhir = env.WhereIs('menhir', env['ENV']['PATH'], '')
  if menhir == None:
    menhir_tool = None
  else:
    menhir_tool = tempfile.gettempdir() + '\\menhir.exe'
    Execute(Copy(menhir_tool, menhir))
else:
  menhir_tool = conf.CheckProg('menhir') # returns None or the full path to it

menhir_min_version=20161115
if menhir_tool:
  output = subprocess.check_output([menhir_tool, '--version'])
  srch = re.search(r'.*version ([0-9]*)', output)
  version = int(srch.group(1))
  if version < menhir_min_version:
    raise SCons.Errors.UserError('Correct version of menhir not found (needs a version newer than %d, is %d)'% (menhir_min_version,version))
  env['MENHIR'] = menhir_tool
else:
  raise SCons.Errors.UserError('Cannot find menhir')

env['ENV']['MENHIRLIB'] = os.environ['MENHIRLIB']
env['ENV']['OCAMLFIND_CONF']=os.environ['OCAMLFIND_CONF']
env['ENV']['OCAML_TOPLEVEL_PATH']=os.environ['OCAML_TOPLEVEL_PATH']
env['MENHIRARGS']='' #'--explain --infer -la 1 --table'
env['OCAMLLEX']='ocamllex'
env['OCAMLBUILD']='ocamlbuild'
env['OCAMLBUILDARGS']='-cflag \'-g\' -I src/ocaml-output -I src/basic/ml ' \
                      '-I src/parser/ml -I src/fstar/ml -I src/extraction/ml -j 24 -build-dir src/ocaml-output/_build ' \
                      '-I src/prettyprint/ml -I src/tactics/ml -I ulib/ml -I ulib/ml/compiler -use-ocamlfind'

parse_mly=env.Command('parse.mly', '../parser/parse.mly',
                      ['cd ../..',
                       '$MENHIR $MENHIRARGS --only-preprocess-for-ocamlyacc $SOURCE >$TARGET'])

parse_ml=env.Command(['parse.ml', 'parse.mli'], 'parse.mly', 'ocamlyacc $SOURCE')

# generate FStar.Parser.Parse.fsti from parser/parse.fsi
def generate_fstar_parser_parse_ml(target, source, env):
  parse_mly = str(source[0])
  subprocess.check_output(['ocamlyacc', parse_mly])

  # read the source file into memory
  parse_ml = 'ocaml-output/parse.ml'
  parse_mli= 'ocaml-output/parse.mli'
  try:
    fd = open(parse_ml, 'r')
  except (OSError,IOError), e:
    raise SCons.Errors.UserError("Can't read source file %s" % parse_ml)
  sourcefile = fd.read()
  fd.close()

  # delete the temporary files as they are not tracked by SCons and
  # ocamlbuild complains downstream if they are present.
  os.remove(parse_ml)
  os.remove(parse_mli)

  # write the target file
  try:
    fd = open(target[0].get_path(), "w")
  except (OSError,IOError), e:
    raise SCons.Errors.UserError("Can't write target file %s" % target[0])

  fd.write('open Prims\n')
  fd.write('open FStar_Errors\n')
  fd.write('open FStar_List\n')
  fd.write('open FStar_Util\n')
  fd.write('open FStar_Range\n')
  fd.write('open FStar_Options\n')
  fd.write('open FStar_Syntax_Syntax\n')
  fd.write('open FStar_Parser_Const\n')
  fd.write('open FStar_Syntax_Util\n')
  fd.write('open FStar_Parser_AST\n')
  fd.write('open FStar_Parser_Util\n')
  fd.write('open FStar_Const\n')
  fd.write('open FStar_Ident\n')
  fd.write('open FStar_String\n')
  fd.write(sourcefile)
  fd.close()

fstar_parser_parse_ml=env.Command('FStar_Parser_Parse.ml', File('parse.mly'), generate_fstar_parser_parse_ml)

# generate FStar_Version.ml from version.txt and other data
def generate_fstar_version_ml(target, source, env):
  # read the source file into memory
  try:
    fd = open(source[0].get_path(), 'r')
  except (OSError,IOError), e:
    raise SCons.Errors.UserError("Can't read source file %s" % source[0])
  sourcefile = fd.read().split('\r\n')
  fd.close()
  VERSION = sourcefile[0]

  # the Makefile showed local time along with timezone.  Python27 doesn't support timezones, so report UTC instead
  utcnow = datetime.datetime.utcnow().replace(microsecond=0)
  DATE = utcnow.isoformat()

  if sys.platform == 'win32':
    if os.getenv('PROCESSOR_ARCHITECTURE')=='AMD64':
      PLATFORM='Windows_x64'
    else:
      PLATFORM='Windows_x86'
  else:
    PLATFORM=os.uname()[4]  # machine is at index 4

  COMPILER = 'OCaml ' + subprocess.check_output(['ocamlc', '-version']).split('\r\n')[0]

  # implement tools/get_commit directly
  COMMIT = subprocess.check_output(['git', 'log','--pretty=format:%h','-n','1'])
  try:
    subprocess.check_output(['git', 'diff','--exit-code','HEAD'], stderr=subprocess.STDOUT)
  except subprocess.CalledProcessError as e:
    # if we get here, the git diff returned nonzero, indicating a dirty source tree
    COMMIT = COMMIT + ' (dirty)'

  try:
    fd = open(target[0].get_path(), "w")
  except (OSError,IOError), e:
    raise SCons.Errors.UserError("Can't write target file %s" % target[0])

  fd.write('open FStar_Util\n')
  fd.write('let dummy () = ();;\n')
  fd.write('FStar_Options._version := "' + VERSION + '";;\n')
  fd.write('FStar_Options._platform := "' + PLATFORM + '";;\n')
  fd.write('FStar_Options._compiler := "' + COMPILER + '";;\n')
  fd.write('FStar_Options._date := "' + DATE + '";;\n')
  fd.write('FStar_Options._commit:= "' + COMMIT + '";;\n')
  fd.close()

fstar_version_ml=env.Command('FStar_Version.ml', '../../version.txt', generate_fstar_version_ml)

readpipe, writepipe = os.pipe()
os.write(writepipe, 'print_endline Sys.ocaml_version')
os.close(writepipe)
OCAML_VERSION = subprocess.check_output(['ocaml','get_branch.ml'], stdin=readpipe).split('\r\n')[0]
os.close(readpipe)
env.Command('../extraction/ml/FStar_Extraction_ML_PrintML.ml',
            '../extraction/ml/FStar_Extraction_ML_PrintML_'+OCAML_VERSION+'.ml',
            Copy('$TARGET', '$SOURCE'))

# generate ../parser/boot/parse.fsy from parse.mly
def generate_parse_fsy(target, source, env):
  # read the source file into memory
  try:
    fd = open(source[0].get_path(), 'r')
  except (OSError,IOError), e:
    raise SCons.Errors.UserError("Can't read source file %s" % source[0])
  sourcelines = fd.read().split('\n')
  fd.close()

  targetlines = ['%{']
  targetlines.append('#light "off"')
  targetlines.append('// (c) Microsoft Corporation. All rights reserved')
  targetlines.append('open Prims')
  targetlines.append('open FStar')
  targetlines.append('open FStar.Errors')
  targetlines.append('open FStar.List')
  targetlines.append('open FStar.Util')
  targetlines.append('open FStar.Range')
  targetlines.append('open FStar.Options')
  targetlines.append('open FStar.Parser.Const')
  targetlines.append('open FStar.Parser.AST')
  targetlines.append('open FStar.Parser.Util')
  targetlines.append('open FStar.Const')
  targetlines.append('open FStar.Ident')
  targetlines.append('open FStar.String')
  # TODO : fsyacc seems to complain as soon as there is an arrow -> in a %type declaration...
  for s in sourcelines:
    if re.match(r'/%{', s):
      continue
    elif re.match(r'^open ', s):
      continue
    elif re.match(r'%token.*->.*', s):
      continue
    elif re.match(r'%type.*->.*', s):
      continue
    if re.match(r'%token|%type', s):
      s = re.sub(r'[a-zA-Z0-9_]*\.','', s)
    if re.match(r'%token.*->.*', s):
      continue
    if re.match(r'%type.*->.*', s):
      continue
    targetlines.append(s)

  # write the target file
  try:
    fd = open(target[0].get_path(), "wb")
  except (OSError,IOError), e:
    raise SCons.Errors.UserError("Can't write target file %s" % target[0])
  for l in targetlines:
    sl = l.split('\n')
    for s in sl:
      fd.write(s)
  fd.close()

fstar_version_ml=env.Command(File('#/../parser/boot/parse.fsy'), File('parse.mly'), generate_parse_fsy)

GENERATED_FILES=['parse.mly','FStar_Parser_Parse.ml','FStar_Version.ml','../extraction/ml/FStar_Extraction_ML_PrintML.ml','../parser/boot/parse.fsy']

main_native = env.Command('_build/src/fstar/ml/main.native', '', 'cd .. && $OCAMLBUILD $OCAMLBUILDARGS main.native')
for g in GENERATED_FILES:
  Depends(main_native, File('#/ocaml-output/'+g))
fstar_exe = env.Command('../../bin/fstar.exe', main_native, Copy('$TARGET', '$SOURCE'))

Return('fstar_exe')

