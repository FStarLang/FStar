import sys
import os, os.path
import re
import collections
import subprocess
import traceback
import SCons

Import('My_env')

env = My_env.Clone()  # ensure changes here don't have impact on other SConscripts
ocaml_output = 'ocaml-output/'  # directory to extract Ocaml code to

# --------------------------------------------------------------------
# Generate boot files
# --------------------------------------------------------------------

# Return a list, where each element is the concatenation of prefix 'p' with the original element
def addprefix(p, l):
  if isinstance(l, basestring):
    # l is a space-separated string.  Split into a list of strings.
    l = l.split(' ')
  # else l is a list to begin with
  return [p+x for x in l]

# Scons action, which takes a text source file, and emits a text target file,
# having used the generator function to transform source to target.
def generate_boot_file(target, source, env, generator):
    # read the source file into memory
    try:
        fd = open(source[0].get_path(), 'r')
    except (OSError,IOError), e:
        raise SCons.Errors.UserError("Can't read source file %s" % source[0])
    sourcefile = fd.read()
    sourcelines = re.split('\r|\n', sourcefile)
    fd.close()

    # munge the source file into the target file
    targetlines = generator(sourcelines)

    # write the target file
    try:
        fd = open(target[0].get_path(), "w")
    except (OSError,IOError), e:
        raise SCons.Errors.UserError("Can't write target file %s" % target[0])
    for l in targetlines:
        fd.write(l)
        fd.write('\n')
    fd.close()

# Scons action, which takes a text source file, and emits a text target file,
# having used the generator function to transform each line of source to target.
def generate_boot_file_ex(target, source, env, generator):
  def LineByLineGenerator(sourcelines):
    targetlines = []
    for s in sourcelines:
      t = generator(s)
      if t != None:
        targetlines.append(t)
    return targetlines
  generate_boot_file(target, source, env, LineByLineGenerator)

# Generate boot/FStar.Tactics.Interpreter.fst from tactics/boot/FStar.Tactics.Interpreter.fs
def generate_TacticsInterpreter(target, source, env):
  def process(s):
    if re.search(r'// *JUST *FSHARP *', s):
      return None
    t = re.sub(r'// *IN F\* *:', '', s)
    return t
  return generate_boot_file_ex(target, source, env, process)

# Generate 'boot/FStar.Parser.Parse.fsti from parser/boot/parser.fsi
def generate_ParserParse(target, source, env):
  def process(sourcelines):
    match = 'module FStar.Parser.Parse'
    replace = 'module FStar.Parser.Parse\nopen FStar.All\nopen FStar.BaseTypes\ntype bytes = array<byte>'
    targetlines = ['#light "off"']
    for i in range(0,len(sourcelines)-13):
      targetlines.append(sourcelines[i].replace(match, replace))
    return targetlines
  return generate_boot_file(target, source, env, process)

# Generate a file by simply copying it
def generate_Copy(target, source, env):
  def process(s):
    return s
  return generate_boot_file_ex(target, source, env, process)

# Generate boot/%.fsti from basic/boot/%.fsi
def generate_Basic(target, source, env):
  def process(s):
    if re.search(r'// *JUST *FSHARP *', s):
      return None
    t = re.sub(r'<.* when .* : equality>', '', s)
    return t
  return generate_boot_file_ex(target, source, env, process)

# Generate boot/%.fsti from prettyprint/boot/%.fsi
def generate_PrettyPrint(target, source, env):
  def process(s):
    if re.search(r'// *JUST *FSHARP *', s):
      return None
    return s
  return generate_boot_file_ex(target, source, env, process)

# all boot files are listed here
ALL_BOOT=addprefix('boot/FStar.',
  ['Util.fsti','List.fsti','Bytes.fsti','String.fsti',
   'Range.fsti','Pprint.fsti','Parser.Parse.fsti',
   'Tactics.Interpreter.fst','Tactics.Interpreter.fsti'])

# Instructions on how to generate all of the ALL_BOOT files
              # tuples of:  (target filename, source filename, and how to generate)
Boot_Rules = [('boot/FStar.Tactics.Interpreter.fst', 'tactics/boot/FStar.Tactics.Interpreter.fs', generate_TacticsInterpreter),
              ('boot/FStar.Parser.Parse.fsti', 'parser/boot/parse.fsi', generate_ParserParse),
              ('boot/FStar.Parser.Parse.fst', 'parser/boot/parser.fs', generate_Copy),
              ('boot/FStar.Tactics.Interpreter.fsti', 'tactics/boot/FStar.Tactics.Interpreter.fsi', generate_Copy),
              ('boot/%.fsti', 'basic/boot/%.fsi', generate_Basic),
              ('boot/%.fsti', 'prettyprint/boot/%.fsi', generate_PrettyPrint),
              ('boot/%.fst', 'basic/boot/%.fs', generate_Copy)
              ]

# Split a pathname into a tuple of (path, basename, extension)
def split_path(p):
  p, n = os.path.split(p)
  root, ext = os.path.splitext(n)
  Parts = collections.namedtuple('Parts', 'path basename extension')
  return Parts(p, root, ext)

# Generate build targets for all files in ALL_BOOT, using the Boot_Rules
boot_target = env.Alias('boot')
for t in ALL_BOOT:
  tparts = split_path(t)
  x = None
  for target, source, action in Boot_Rules:
    if target == t:
        x = env.Command(target, source,  action)
        break
    elif '%' in target:
      # split t into path, basename, and extension
      sourceparts = split_path(source)
      computedsource = sourceparts.path + '/' + tparts.basename + sourceparts.extension
      if os.path.exists(computedsource):
        targetparts = split_path(target)
        computedtarget = targetparts.path + '/' + tparts.basename + targetparts.extension
        x = env.Command(computedtarget, computedsource, action)
        break
  if x == None:
    raise SCons.Errors.UserError('Boot file %s didn\'t match any rule in Boot_Rules'%t)
  env.Alias(boot_target, x)

# --------------------------------------------------------------------
# Extract boot files to .ml
# --------------------------------------------------------------------
if sys.platform == 'win32' or sys.platform == 'cygwin':  # Windows
    fstar_path = '../bin/fstar.exe'
else:  # Unix
    fstar_path = os.path.realpath('../bin/fstar.exe')
    if os.path.exists(fstar):
        filetype = subprocess.check_output(['file',fstar_path])
        if filetype.contains('Mono'):
            env['FSTAR'] = 'mono ' + env['FSTAR']  # F# version, mono fstar.exe
        else:
            env['FSTAR'] = fstar_path                           # OCaml verion, fstar.exe

boot_includes=addprefix('--include ', '../ulib boot basic extraction format fsdoc fstar '+\
                                      'parser prettyprint reflection smtencoding syntax '+\
                                      'tactics tosyntax typechecker')

# This is the way in which we invoke F* for boostrapping
#   -- we use automatic dependence analysis based on files in ulib, src/{basic, ...} and boot
#   -- eager_inference, MLish, lax: all tune type-inference for use with unverified ML programs
env['FSTARARGS'] = '$OTHERFLAGS --eager_inference --lax --MLish --no_location_info ' + \
  '--odir ocaml-output --codegen OCaml ' + ' '.join(boot_includes)

ExtractionAction = collections.namedtuple('ExtractionAction', 'source target command')

# Common base for ExtractModule and ExtractNamespace
class ExtractionBase:
  def __init__(self):
    self.commonaction = ''
    self.actions = [];    # list of ExtractionAction tuples
    
# Generate the .ml target filename given an F* source filename
def GetTargetNameFromSourceFile(sourcefile):
  path,filename = os.path.split(sourcefile)
  base,ext = os.path.splitext(filename)
  return base.replace('.','_') + '.ml'

# Helper class for extracting a set of modules
class ExtractModules(ExtractionBase):
  def __init__(self, modulelist):
    ExtractionBase.__init__(self)
    for mtuple in modulelist:
      module, src = mtuple
      action = ExtractionAction(src, ocaml_output+module.replace('.','_') + '.ml', '--extract_module '+module);
      self.actions.append(action)

# Helper class for extracting a set of namespaces
class ExtractNamespace(ExtractionBase):
  def __init__(self, sources, namespace, noextractions=[]):
    ExtractionBase.__init__(self)
    if type(sources)==type(''):
      sources = sources.split(' ')
    if type(noextractions)==type(''):
      noextractions = noextractions.split(' ')
    sources = Flatten(sources)
    argslist = [' --extract_namespace ' + namespace] + [' --no_extract ' + noextract for noextract in noextractions]
    self.commonaction = ' '.join(argslist)
    for file in sources:
      action = ExtractionAction(file, ocaml_output+GetTargetNameFromSourceFile(file), '')
      self.actions.append(action)

# --------------------------------------------------------------------
# The list of all things to extract from the boot files
# Tuples are:  (targetname, ExtractModules|ExtractNamespace)
# --------------------------------------------------------------------
Extractions=[
  ('extract_misc',ExtractModules([
    ('FStar.Pervasives',    'basic/FStar.Common.fs'),
    ('FStar.Common',        'basic/FStar.Common.fs'),
    ('FStar.Options',       'basic/FStar.Options.fs'),
    ('FStar.Ident',         'basic/FStar.Ident.fs'),
    ('FStar.Errors',        'basic/FStar.Errors.fs'),
    ('FStar.Const',         'basic/FStar.Const.fs'),
    ('FStar.Order',         'basic/FStar.Order.fs'),
    ('FStar.Format',        'format/FStar.Format.fs')
  ])),
  ('extract_syntax_basic',ExtractNamespace(
   [addprefix('syntax/FStar.Syntax.','Syntax.fs Subst.fs Free.fs InstFV.fs Util.fs Print.fs Embeddings.fs MutRecTy.fs Resugar.fs Unionfind.fs')],
   'FStar.Syntax')
   ),
  ('extract_fsdoc',ExtractNamespace(
   ['fsdoc/FStar.Fsdoc.Generator.fs'],
   'FStar.Fsdoc')
   ),
   ('extract_parser',ExtractNamespace(
   addprefix('parser/FStar.Parser.','AST.fs Const.fs Driver.fs Dep.fs ToDocument.fs'),
   'FStar.Parser',
   'FStar.Parser.ParseIt') # --no-extract FStar.Parser.ParseIt
   ),
  ('extract_normalizer',ExtractNamespace(
   addprefix('typechecker/FStar.TypeChecker.','Common.fs Env.fs Normalize.fs Err.fs'),
   'FStar.TypeChecker')
   ),
  ('extract_rel',ExtractModules([
   ('FStar.TypeChecker.Rel', 'typechecker/FStar.TypeChecker.Rel.fs')
   ])),
  ('extract_util',ExtractModules([
   ('FStar.TypeChecker.Util', 'typechecker/FStar.TypeChecker.Util.fs')
   ])),
  ('extract_dmff',ExtractModules([
   ('FStar.TypeChecker.DMFF', 'typechecker/FStar.TypeChecker.DMFF.fs')
   ])),
  ('extract_tcterm',ExtractModules([
   ('FStar.TypeChecker.TcTerm', 'typechecker/FStar.TypeChecker.TcTerm.fs')
   ])),
  ('extract_tcinductive',ExtractModules([
   ('FStar.TypeChecker.TcInductive', 'typechecker/FStar.TypeChecker.TcInductive.fs')
   ])),
  ('extract_tc',ExtractModules([
   ('FStar.TypeChecker.Tc', 'typechecker/FStar.TypeChecker.Tc.fs')
   ])),
  ('extract_tosyntax',ExtractNamespace(
   addprefix('tosyntax/FStar.ToSyntax.','Env.fs Interleave.fs ToSyntax.fs'),
   'FStar.ToSyntax')
   ),
  ('extract_extraction',ExtractNamespace(
   addprefix('extraction/FStar.Extraction.','ML.Syntax.fs ML.UEnv.fs ML.Util.fs ML.Code.fs ML.Term.fs ML.Modul.fs Kremlin.fs'),
   'FStar.Extraction')
   ),
  ('extract_tactics',ExtractNamespace(
   [addprefix('tactics/FStar.Tactics.','Types.fs Basic.fs Embedding.fs'), 'boot/FStar.Tactics.Interpreter.fst'],
   'FStar.Tactics',
   'FStar.Tactics.Native')  # --no-extract FStar.Tactics.Native
   ),
  ('extract_reflection',ExtractNamespace(
   addprefix('reflection/FStar.Reflection.','Basic.fs Data.fs Interpreter.fs'),
   'FStar.Reflection',
   'FStar.Reflection.Types')  # --no-extract FStar.Reflection.Types
   ),
  ('extract_smtencoding_base',ExtractNamespace(
   addprefix('smtencoding/FStar.SMTEncoding.','Term.fs Util.fs Z3.fs SplitQueryCases.fs ErrorReporting.fs'),
   'FStar.SMTEncoding')
   ),
  ('extract_encode',ExtractModules([
   ('FStar.SMTEncoding.Encode', 'smtencoding/FStar.SMTEncoding.Encode.fs')
   ])),
  ('extract_solver',ExtractModules([
   ('FStar.SMTEncoding.Solver', 'smtencoding/FStar.SMTEncoding.Solver.fs')
   ])),
  ('extract_fstar',ExtractModules([
   ('FStar.Dependencies',       'fstar/FStar.Dependencies.fs'),
   ('FStar.Interactive',        'fstar/FStar.Interactive.fs'),
   ('FStar.Legacy.Interactive', 'fstar/FStar.Legacy.Interactive.fs'),
   ('FStar.Universal',          'fstar/FStar.Universal.fs'),
   ('FStar.Indent',             'fstar/FStar.Indent.fs'),
   ('FStar.Main',               'fstar/FStar.Main.fs')
   ]))
]

# List of handy target names that alias sets of targets listed above
ExtractionTargets = [
  ('extract_syntax',     'extract_syntax_basic extract_fsdoc'),
  ('extract_typechecker','extract_normalizer extract_rel extract_util extract_dmff extract_tcterm extract_tcinductive extract_tc'),
  ('extract_smtencoding','extract_smtencoding_base extract_encode extract_solver'),
  ('extract_all',        'extract_tactics extract_reflection extract_misc extract_syntax extract_parser extract_typechecker extract_tosyntax extract_smtencoding extract_extraction extract_fstar')
]

# Generate SCons targets for each Extraction entry
extraction_targets = {}
for name, e in Extractions:
  command = '$FSTAR $FSTARARGS $CHANGED_SOURCES ' + e.commonaction + ' '
  for action in e.actions:
    command += ' ' + action.command
  # Set batch_key=None to have Scons launch fstar.exe separately for each .ml file to extract
  fstar_builder = Builder(action=Action(command, batch_key=True, targets='$CHANGED_TARGETS'))
  # Clone the environment for each Extraction, so each can have a different
  # FStarBuilder.  Their command lines all differ.
  benv = env.Clone()
  benv.Append(BUILDERS={'FStarBuilder':fstar_builder})
  for action in e.actions:
    print 'builder'+str(action.target)+' ' + str(action.source)
    t_cmd = benv.FStarBuilder(action.target, action.source)
    #benv.Depends(t_cmd, benv['FSTAR'])  # take explicit dependency on the F* compiler executable
    benv.Alias(name, t_cmd)            # add this target to the alias

# Turn the ExtractionTargets[] into actual SCons targets
for name, targets in ExtractionTargets:
  for t in targets.split(' '):
    env.Alias(name, t)
extract_target = env.Alias('extract', 'extract_all')


# --------------------------------------------------------------------
# Automatic dependency scanning
# --------------------------------------------------------------------
def formatExceptionInfo(maxTBlevel=5):
   cla, exc, trbk = sys.exc_info()
   excName = cla.__name__
   try:
       excArgs = exc.__dict__["args"]
   except KeyError:
       excArgs = "<no args>"
   excTb = traceback.format_tb(trbk, maxTBlevel)
   return (excName, excArgs, excTb)

# launch an external process and return its stdout as a list of lines of text
def docmd(env, cmd):
  try:
    pipe = SCons.Action._subproc(env, cmd,
                                 stdin = 'devnull',
                                 stderr = 'devnull',
                                 stdout = subprocess.PIPE)  
  except:
    e = sys.exc_info()[0]
    print ("Error invoking: %s" % cmd)
    print formatExceptionInfo()
    print ("Exception: %s" % e)
    Exit(1)
  result = []
  line = pipe.stdout.readline()
  while line:
    result.append(line)
    line = pipe.stdout.readline()
  return result
  
# Scan a .fs file to discover its dependencies, and add .fst/.fsti targets for each.
# Returns a list of File representing the discovered .fs dependencies.      
def fs_file_scan(node, env, path):
  # convert from Node to string and fully qualify.  FStar will emit the
  # name in the dependency output as specified on the command line, and
  # we want fully qualified names only in the output.
  fullnode = os.path.abspath(str(node))
  print('Dependency scan: ' + fullnode)
  output = docmd(env, env.subst('$FSTAR $FSTARARGS --dep make') + ' ' + fullnode)
  deps = []
  # output is a list of lines of the form "file: file[ file]*"
  for deplist in output:
    s = deplist.rstrip().split(' ') # trim \r and \n then split by spaces
    target = s[0][:-1] #the 0th string is the target name.  Remove the trailing ':'
    sources = s[1:]    #the remaining strings are the sources.
    deps.append(target)
    deps += sources
  return deps

# register the .fs scanner with SCons
fs_scan = Scanner(function = fs_file_scan, skeys = ['.fs'])
env.Append(SCANNERS = fs_scan)

# --------------------------------------------------------------------

Return('boot_target', 'extract_target')
