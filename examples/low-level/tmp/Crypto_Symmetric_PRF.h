/* This file auto-generated by KreMLin! */
#ifndef __Crypto_Symmetric_PRF_H
#define __Crypto_Symmetric_PRF_H


#include "Prims.h"
#include "FStar_Mul.h"
#include "FStar_Squash.h"
#include "FStar_StrongExcludedMiddle.h"
#include "FStar_List_Tot.h"
#include "FStar_Classical.h"
#include "FStar_ListProperties.h"
#include "FStar_SeqProperties.h"
#include "FStar_Math_Lemmas.h"
#include "FStar_BitVector.h"
#include "FStar_UInt.h"
#include "FStar_Int.h"
#include "FStar_FunctionalExtensionality.h"
#include "FStar_PropositionalExtensionality.h"
#include "FStar_PredicateExtensionality.h"
#include "FStar_TSet.h"
#include "FStar_Set.h"
#include "FStar_Map.h"
#include "FStar_Ghost.h"
#include "FStar_All.h"
#include "FStar_Bytes.h"
#include "FStar_Buffer.h"
#include "Buffer_Utils.h"
#include "Crypto_Symmetric_Bytes.h"
#include "Crypto_Symmetric_Poly1305_Spec.h"
#include "Crypto_Symmetric_Poly1305_Parameters.h"
#include "Crypto_Symmetric_Poly1305_Bigint.h"
#include "Crypto_Symmetric_Poly1305_Bignum_Lemmas_Part1.h"
#include "Crypto_Symmetric_Poly1305_Bignum_Lemmas_Part2.h"
#include "Crypto_Symmetric_Poly1305_Bignum_Lemmas_Part3.h"
#include "Crypto_Symmetric_Poly1305_Bignum_Lemmas_Part4.h"
#include "Crypto_Symmetric_Poly1305_Bignum_Lemmas_Part5.h"
#include "FStar_Buffer_Quantifiers.h"
#include "Crypto_Indexing.h"
#include "Flag.h"
#include "Crypto_Symmetric_AES.h"
#include "Intrinsics.h"
#include "Crypto_Symmetric_AES128.h"
#include "Crypto_Symmetric_Chacha20.h"
#include "Crypto_Symmetric_Cipher.h"
#include "Crypto_Symmetric_Poly1305_Lemmas.h"
#include "Crypto_Symmetric_Poly1305_Bignum_Lemmas_Part6.h"
#include "Crypto_Symmetric_Poly1305_Bignum.h"
#include "Crypto_Symmetric_Poly1305.h"
#include "Crypto_Symmetric_GF128_Spec.h"
#include "Crypto_Symmetric_GF128.h"
#include "Crypto_Symmetric_MAC.h"
#include "Crypto_Symmetric_UF1CMA.h"
#include "Crypto_Plain.h"
#include "kremlib.h"
#include "testlib.h"

uint32_t Crypto_Symmetric_PRF_blocklen(Crypto_Indexing_id i);

uint32_t Crypto_Symmetric_PRF_keylen(Crypto_Indexing_id i);

uint32_t Crypto_Symmetric_PRF_statelen(Crypto_Indexing_id i);

typedef FStar_HyperHeap_rid Crypto_Symmetric_PRF_region;

uint32_t Crypto_Symmetric_PRF_maxCtr(Crypto_Indexing_id i);

typedef struct {
  FStar_UInt128_t iv;
  uint32_t ctr;
}
Crypto_Symmetric_PRF_domain____;

Crypto_Symmetric_PRF_domain____
Crypto_Symmetric_PRF_incr(Crypto_Indexing_id i, Crypto_Symmetric_PRF_domain____ x);

bool
Crypto_Symmetric_PRF_above(
  Crypto_Indexing_id i,
  Crypto_Symmetric_PRF_domain____ x,
  Crypto_Symmetric_PRF_domain____ z
);

typedef struct {
  uint32_t x00;
  void *x01;
  void *x02;
}
Crypto_Symmetric_PRF_otp____;

uint32_t
Crypto_Symmetric_PRF____OTP___l(Crypto_Indexing_id i, Crypto_Symmetric_PRF_otp____ projectee);

void
*Crypto_Symmetric_PRF____OTP____1(Crypto_Indexing_id i, Crypto_Symmetric_PRF_otp____ projectee);

void
*Crypto_Symmetric_PRF____OTP___cipher(
  Crypto_Indexing_id i,
  Crypto_Symmetric_PRF_otp____ projectee
);

uint32_t Crypto_Symmetric_PRF_ctr_0(Crypto_Indexing_id i);

extern FStar_UInt128_t Crypto_Symmetric_PRF_iv_0;

uint8_t
*Crypto_Symmetric_PRF_sk0Range(
  FStar_HyperHeap_rid rgn,
  Crypto_Indexing_id i,
  Crypto_Symmetric_PRF_domain____ x,
  void *z
);

Crypto_Symmetric_UF1CMA_state____
Crypto_Symmetric_PRF_macRange(
  FStar_HyperHeap_rid rgn,
  Crypto_Indexing_id i,
  Crypto_Symmetric_PRF_domain____ x,
  void *z
);

Crypto_Symmetric_PRF_otp____
Crypto_Symmetric_PRF_otpRange(
  FStar_HyperHeap_rid rgn,
  Crypto_Indexing_id i,
  Crypto_Symmetric_PRF_domain____ x,
  void *z
);

void
*Crypto_Symmetric_PRF_blkRange(
  FStar_HyperHeap_rid rgn,
  Crypto_Indexing_id i,
  Crypto_Symmetric_PRF_domain____ x,
  void *z
);

typedef struct {
  Crypto_Symmetric_PRF_domain____ x00;
  void *x01;
}
Crypto_Symmetric_PRF_entry_______;

Crypto_Symmetric_PRF_domain____
Crypto_Symmetric_PRF____Entry___x(
  FStar_HyperHeap_rid rgn,
  Crypto_Indexing_id i,
  Crypto_Symmetric_PRF_entry_______ projectee
);

void
Crypto_Symmetric_PRF____Entry___range(
  FStar_HyperHeap_rid rgn,
  Crypto_Indexing_id i,
  Crypto_Symmetric_PRF_entry_______ projectee
);

bool
Crypto_Symmetric_PRF_is_entry_domain(
  Crypto_Indexing_id i,
  FStar_HyperHeap_rid rgn,
  Crypto_Symmetric_PRF_domain____ x,
  Crypto_Symmetric_PRF_entry_______ e
);

typedef struct {
  enum { Prims_option_____None, Prims_option_____Some } tag;
  union {
    struct {  } case_None;
    struct { void *v; } case_Some;
  }
  ;
}
Prims_option____;

Prims_option____
Crypto_Symmetric_PRF_find(
  FStar_HyperHeap_rid rgn,
  Crypto_Indexing_id i,
  void *s,
  Crypto_Symmetric_PRF_domain____ x
);

Prims_option__uint8_t_
Crypto_Symmetric_PRF_find_sk0(
  FStar_HyperHeap_rid rgn,
  Crypto_Indexing_id i,
  void *s,
  Crypto_Symmetric_PRF_domain____ x
);

typedef struct {
  enum {
    Prims_option__Crypto_Symmetric_UF1CMA_state_____None,
    Prims_option__Crypto_Symmetric_UF1CMA_state_____Some
  }
  tag;
  union {
    struct {  } case_None;
    struct { Crypto_Symmetric_UF1CMA_state____ v; } case_Some;
  }
  ;
}
Prims_option__Crypto_Symmetric_UF1CMA_state____;

Prims_option__Crypto_Symmetric_UF1CMA_state____
Crypto_Symmetric_PRF_find_mac(
  FStar_HyperHeap_rid rgn,
  Crypto_Indexing_id i,
  void *s,
  Crypto_Symmetric_PRF_domain____ x
);

typedef struct {
  enum {
    Prims_option__Crypto_Symmetric_PRF_otp_____None,
    Prims_option__Crypto_Symmetric_PRF_otp_____Some
  }
  tag;
  union {
    struct {  } case_None;
    struct { Crypto_Symmetric_PRF_otp____ v; } case_Some;
  }
  ;
}
Prims_option__Crypto_Symmetric_PRF_otp____;

Prims_option__Crypto_Symmetric_PRF_otp____
Crypto_Symmetric_PRF_find_otp(
  FStar_HyperHeap_rid rgn,
  Crypto_Indexing_id i,
  void *s,
  Crypto_Symmetric_PRF_domain____ x
);

typedef struct {
  enum { Prims_option__FStar_Seq_seq_uint8_t_None, Prims_option__FStar_Seq_seq_uint8_t_Some }
  tag;
  union {
    struct {  } case_None;
    struct { void *v; } case_Some;
  }
  ;
}
Prims_option__FStar_Seq_seq_uint8_t;

Prims_option__FStar_Seq_seq_uint8_t
Crypto_Symmetric_PRF_find_blk(
  FStar_HyperHeap_rid rgn,
  Crypto_Indexing_id i,
  void *s,
  Crypto_Symmetric_PRF_domain____ x
);

typedef struct {
  FStar_HyperHeap_rid x00;
  FStar_HyperHeap_rid x01;
  uint8_t *x02;
  void *x03;
}
Crypto_Symmetric_PRF_state____;

FStar_HyperHeap_rid
Crypto_Symmetric_PRF____State___rgn(
  Crypto_Indexing_id i,
  Crypto_Symmetric_PRF_state____ projectee
);

FStar_HyperHeap_rid
Crypto_Symmetric_PRF____State___mac_rgn(
  Crypto_Indexing_id i,
  Crypto_Symmetric_PRF_state____ projectee
);

uint8_t
*Crypto_Symmetric_PRF____State___key(
  Crypto_Indexing_id i,
  Crypto_Symmetric_PRF_state____ projectee
);

void
Crypto_Symmetric_PRF____State___table(
  Crypto_Indexing_id i,
  Crypto_Symmetric_PRF_state____ projectee
);

void *Crypto_Symmetric_PRF_itable(Crypto_Indexing_id i, Crypto_Symmetric_PRF_state____ s);

void
Crypto_Symmetric_PRF_mktable(
  Crypto_Indexing_id i,
  FStar_HyperHeap_rid rgn,
  FStar_HyperHeap_rid mac_rgn,
  void *r
);

void
Crypto_Symmetric_PRF_no_table(
  Crypto_Indexing_id i,
  FStar_HyperHeap_rid rgn,
  FStar_HyperHeap_rid mac_rgn
);

uint8_t *Crypto_Symmetric_PRF_leak(Crypto_Indexing_id i, Crypto_Symmetric_PRF_state____ st);

void
Crypto_Symmetric_PRF_getBlock(
  Crypto_Indexing_id i,
  Crypto_Symmetric_PRF_state____ t,
  Crypto_Symmetric_PRF_domain____ x,
  uint32_t len,
  uint8_t *output
);

extern Prims_int Crypto_Symmetric_PRF_zero;

void
Crypto_Symmetric_PRF_prf_blk(
  Crypto_Indexing_id i,
  Crypto_Symmetric_PRF_state____ t,
  Crypto_Symmetric_PRF_domain____ x,
  uint32_t len,
  uint8_t *output
);

void
Crypto_Symmetric_PRF_prf_dexor(
  Crypto_Indexing_id i,
  Crypto_Symmetric_PRF_state____ t,
  Crypto_Symmetric_PRF_domain____ x,
  uint32_t l,
  uint8_t *cipher,
  uint8_t *plain
);

void
Crypto_Symmetric_PRF_prf_enxor(
  Crypto_Indexing_id i,
  Crypto_Symmetric_PRF_state____ t,
  Crypto_Symmetric_PRF_domain____ x,
  uint32_t l,
  uint8_t *cipher,
  uint8_t *plain
);
#endif
