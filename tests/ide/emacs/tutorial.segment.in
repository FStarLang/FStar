{"query-id": "1", "query": "segment", "args": {"code": "module Tutorial\nopen FStar.ST\nopen FStar.All\n//safe-read-write\n\ntype filename = string\n\n(* canWrite is a function specifying whether or not a file f can be written *)\nlet canWrite (f:filename) =\n  match f with\n    | \"demo/tempfile\" -> true\n    | _ -> false\n\n(* canRead is also a function ... *)\nlet canRead (f:filename) =\n  canWrite f               (* writeable files are also readable *)\n  || f=\"demo/README\"       (* and so is this file *)\n\n\nval read  : f:filename{canRead f}  -> ML string\nlet read f  = FStar.IO.print_string (\"Dummy read of file \" ^ f ^ \"\\n\"); f\n\nval write : f:filename{canWrite f} -> string -> ML unit\nlet write f s = FStar.IO.print_string (\"Dummy write of string \" ^ s ^ \" to file \" ^ f ^ \"\\n\")\n\n\nlet passwd  = \"demo/password\"\nlet readme  = \"demo/README\"\nlet tmp     = \"demo/tempfile\"\n\n\nval staticChecking : unit -> ML unit\nlet staticChecking () =\n  let v1 = read tmp in\n  let v2 = read readme in\n  (* let v3 = read passwd in -- invalid read, fails type-checking *)\n  write tmp \"hello!\"\n  (* ; write passwd \"junk\" -- invalid write , fails type-checking *)\n\n\nexception InvalidRead\nval checkedRead : filename -> ML string\nlet checkedRead f =\n  if canRead f then read f else raise InvalidRead\n\n\nassume val checkedWrite : filename -> string -> ML unit\n\n// solution here\n//\n//\n\n\nlet dynamicChecking () =\n  let v1 = checkedRead tmp in\n  let v2 = checkedRead readme in\n  let v3 = checkedRead passwd in (* this raises exception *)\n  checkedWrite tmp \"hello!\";\n  checkedWrite passwd \"junk\" (* this raises exception *)\n\nlet main = staticChecking (); dynamicChecking ()\n"}}