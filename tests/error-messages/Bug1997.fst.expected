Module after desugaring:
module Bug1997
Declarations: [
[@ ]
let  op_Equals_Hat  : _ = fun a b -> a + b
[@ ]
let  test1  : _ = fun a b c -> a =^ b =^ c
[@ ]
let  test2  : _ = fun a b c -> a =^ b =^ c
[@ ]
let  test3  : _ = fun a b c -> a =^ (b =^ c)
[@ ]
private let  uu___11  : _ = FStar.Pervasives.assert_norm (Bug1997.test1 == Bug1997.test2)
[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___12  : _ = FStar.Pervasives.assert_norm (Bug1997.test1 == Bug1997.test3)
(* / Sig_fail*)

[@ ]
logic let  imp_assoc_0  : _ = fun p q r -> p ==> q ==> r
[@ ]
logic let  imp_assoc_1  : _ = fun p q r -> p ==> q ==> r
[@ ]
logic let  imp_assoc_2  : _ = fun p q r -> (p ==> q) ==> r
[@ ]
private let  uu___22  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_assoc_0 == Bug1997.imp_assoc_1)
[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___23  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_assoc_1 == Bug1997.imp_assoc_2)
(* / Sig_fail*)

[@ ]
logic let  imp_iff_0  : _ = fun p q r -> p ==> q <==> r
[@ ]
logic let  imp_iff_1  : _ = fun p q r -> p ==> q <==> r
[@ ]
logic let  imp_iff_2  : _ = fun p q r -> p ==> (q <==> r)
[@ ]
private let  uu___33  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_iff_0 == Bug1997.imp_iff_1)
[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___34  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_iff_1 == Bug1997.imp_iff_2)
(* / Sig_fail*)

[@ ]
logic let  imp_conj_1  : _ = fun p q r s -> p ==> q /\ r ==> s
[@ ]
logic let  imp_conj_2  : _ = fun p q r s -> (p ==> q) /\ (r ==> s)
[@ ]
logic let  imp_conj_3  : _ = fun p q r s -> p ==> q /\ (r ==> s)
[@ ]
logic let  imp_conj_4  : _ = fun p q r s -> p ==> q /\ r ==> s
[@ ]
private let  uu___51  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_conj_1 == Bug1997.imp_conj_4)
[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___52  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_conj_1 == Bug1997.imp_conj_3)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___53  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_conj_1 == Bug1997.imp_conj_2)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___54  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_conj_2 == Bug1997.imp_conj_3)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___55  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_conj_2 == Bug1997.imp_conj_4)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___56  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_conj_3 == Bug1997.imp_conj_4)
(* / Sig_fail*)

[@ ]
logic let  impneg1  : _ = fun p q r -> p ==> q /\ ~p ==> r
[@ ]
logic let  impneg2  : _ = fun p q r -> (p ==> q) /\ (~p ==> r)
[@ ]
logic let  impneg3  : _ = fun p q r -> p ==> q /\ (~p ==> r)
[@ ]
logic let  impneg4  : _ = fun p q r -> p ==> q /\ ~p ==> r
[@ ]
private let  uu___69  : _ = FStar.Pervasives.assert_norm (Bug1997.impneg1 == Bug1997.impneg4)
[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___70  : _ = FStar.Pervasives.assert_norm (Bug1997.impneg1 == Bug1997.impneg3)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___71  : _ = FStar.Pervasives.assert_norm (Bug1997.impneg1 == Bug1997.impneg2)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___72  : _ = FStar.Pervasives.assert_norm (Bug1997.impneg2 == Bug1997.impneg3)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___73  : _ = FStar.Pervasives.assert_norm (Bug1997.impneg2 == Bug1997.impneg4)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___74  : _ = FStar.Pervasives.assert_norm (Bug1997.impneg3 == Bug1997.impneg4)
(* / Sig_fail*)

[@ ]
logic let  cd1  : _ = fun p q r -> p /\ q \/ r
[@ ]
logic let  cd2  : _ = fun p q r -> p /\ q \/ r
[@ ]
logic let  cd3  : _ = fun p q r -> p /\ (q \/ r)
[@ ]
private let  uu___84  : _ = FStar.Pervasives.assert_norm (Bug1997.cd1 == Bug1997.cd2)
[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___85  : _ = FStar.Pervasives.assert_norm (Bug1997.cd1 == Bug1997.cd3)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___86  : _ = FStar.Pervasives.assert_norm (Bug1997.cd2 == Bug1997.cd3)
(* / Sig_fail*)

[@ ]
logic let  m0  : _ = fun p q r s -> p /\ (q \/ r) /\ s
[@ ]
logic let  m1  : _ = fun p q r s -> p /\ q \/ r /\ s
[@ ]
logic let  m2  : _ = fun p q r s -> p /\ q \/ r /\ s
[@ ]
logic let  m3  : _ = fun p q r s -> p /\ q \/ r /\ s
[@ ]
logic let  m4  : _ = fun p q r s -> p /\ q \/ r /\ s
[@ ]
private let  uu___107  : _ = FStar.Pervasives.assert_norm (Bug1997.m1 == Bug1997.m2)
[@ ]
private let  uu___108  : _ = FStar.Pervasives.assert_norm (Bug1997.m1 == Bug1997.m3)
[@ ]
private let  uu___109  : _ = FStar.Pervasives.assert_norm (Bug1997.m1 == Bug1997.m4)
[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___110  : _ = FStar.Pervasives.assert_norm (Bug1997.m0 == Bug1997.m1)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___111  : _ = FStar.Pervasives.assert_norm (Bug1997.m0 == Bug1997.m2)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___112  : _ = FStar.Pervasives.assert_norm (Bug1997.m0 == Bug1997.m3)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___113  : _ = FStar.Pervasives.assert_norm (Bug1997.m0 == Bug1997.m4)
(* / Sig_fail*)

[@ ]
logic let  n0  : _ = fun p q r s -> p \/ q /\ r \/ s
[@ ]
logic let  n1  : _ = fun p q r s -> p \/ q /\ r \/ s
[@ ]
logic let  n2  : _ = fun p q r s -> (p \/ q) /\ r \/ s
[@ ]
logic let  n3  : _ = fun p q r s -> (p \/ q) /\ (r \/ s)
[@ ]
logic let  n4  : _ = fun p q r s -> p \/ q /\ (r \/ s)
[@ ]
private let  uu___134  : _ = FStar.Pervasives.assert_norm (Bug1997.n0 == Bug1997.n1)
[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___135  : _ = FStar.Pervasives.assert_norm (Bug1997.n1 == Bug1997.n2)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___136  : _ = FStar.Pervasives.assert_norm (Bug1997.n1 == Bug1997.n3)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___137  : _ = FStar.Pervasives.assert_norm (Bug1997.n1 == Bug1997.n4)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___138  : _ = FStar.Pervasives.assert_norm (Bug1997.n2 == Bug1997.n3)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___139  : _ = FStar.Pervasives.assert_norm (Bug1997.n2 == Bug1997.n4)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___140  : _ = FStar.Pervasives.assert_norm (Bug1997.n3 == Bug1997.n4)
(* / Sig_fail*)

]
Exports: [
[@ ]
let  op_Equals_Hat  : _ = fun a b -> a + b
[@ ]
let  test1  : _ = fun a b c -> a =^ b =^ c
[@ ]
let  test2  : _ = fun a b c -> a =^ b =^ c
[@ ]
let  test3  : _ = fun a b c -> a =^ (b =^ c)
[@ ]
private let  uu___11  : _ = FStar.Pervasives.assert_norm (Bug1997.test1 == Bug1997.test2)
[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___12  : _ = FStar.Pervasives.assert_norm (Bug1997.test1 == Bug1997.test3)
(* / Sig_fail*)

[@ ]
logic let  imp_assoc_0  : _ = fun p q r -> p ==> q ==> r
[@ ]
logic let  imp_assoc_1  : _ = fun p q r -> p ==> q ==> r
[@ ]
logic let  imp_assoc_2  : _ = fun p q r -> (p ==> q) ==> r
[@ ]
private let  uu___22  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_assoc_0 == Bug1997.imp_assoc_1)
[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___23  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_assoc_1 == Bug1997.imp_assoc_2)
(* / Sig_fail*)

[@ ]
logic let  imp_iff_0  : _ = fun p q r -> p ==> q <==> r
[@ ]
logic let  imp_iff_1  : _ = fun p q r -> p ==> q <==> r
[@ ]
logic let  imp_iff_2  : _ = fun p q r -> p ==> (q <==> r)
[@ ]
private let  uu___33  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_iff_0 == Bug1997.imp_iff_1)
[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___34  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_iff_1 == Bug1997.imp_iff_2)
(* / Sig_fail*)

[@ ]
logic let  imp_conj_1  : _ = fun p q r s -> p ==> q /\ r ==> s
[@ ]
logic let  imp_conj_2  : _ = fun p q r s -> (p ==> q) /\ (r ==> s)
[@ ]
logic let  imp_conj_3  : _ = fun p q r s -> p ==> q /\ (r ==> s)
[@ ]
logic let  imp_conj_4  : _ = fun p q r s -> p ==> q /\ r ==> s
[@ ]
private let  uu___51  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_conj_1 == Bug1997.imp_conj_4)
[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___52  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_conj_1 == Bug1997.imp_conj_3)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___53  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_conj_1 == Bug1997.imp_conj_2)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___54  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_conj_2 == Bug1997.imp_conj_3)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___55  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_conj_2 == Bug1997.imp_conj_4)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___56  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_conj_3 == Bug1997.imp_conj_4)
(* / Sig_fail*)

[@ ]
logic let  impneg1  : _ = fun p q r -> p ==> q /\ ~p ==> r
[@ ]
logic let  impneg2  : _ = fun p q r -> (p ==> q) /\ (~p ==> r)
[@ ]
logic let  impneg3  : _ = fun p q r -> p ==> q /\ (~p ==> r)
[@ ]
logic let  impneg4  : _ = fun p q r -> p ==> q /\ ~p ==> r
[@ ]
private let  uu___69  : _ = FStar.Pervasives.assert_norm (Bug1997.impneg1 == Bug1997.impneg4)
[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___70  : _ = FStar.Pervasives.assert_norm (Bug1997.impneg1 == Bug1997.impneg3)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___71  : _ = FStar.Pervasives.assert_norm (Bug1997.impneg1 == Bug1997.impneg2)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___72  : _ = FStar.Pervasives.assert_norm (Bug1997.impneg2 == Bug1997.impneg3)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___73  : _ = FStar.Pervasives.assert_norm (Bug1997.impneg2 == Bug1997.impneg4)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___74  : _ = FStar.Pervasives.assert_norm (Bug1997.impneg3 == Bug1997.impneg4)
(* / Sig_fail*)

[@ ]
logic let  cd1  : _ = fun p q r -> p /\ q \/ r
[@ ]
logic let  cd2  : _ = fun p q r -> p /\ q \/ r
[@ ]
logic let  cd3  : _ = fun p q r -> p /\ (q \/ r)
[@ ]
private let  uu___84  : _ = FStar.Pervasives.assert_norm (Bug1997.cd1 == Bug1997.cd2)
[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___85  : _ = FStar.Pervasives.assert_norm (Bug1997.cd1 == Bug1997.cd3)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___86  : _ = FStar.Pervasives.assert_norm (Bug1997.cd2 == Bug1997.cd3)
(* / Sig_fail*)

[@ ]
logic let  m0  : _ = fun p q r s -> p /\ (q \/ r) /\ s
[@ ]
logic let  m1  : _ = fun p q r s -> p /\ q \/ r /\ s
[@ ]
logic let  m2  : _ = fun p q r s -> p /\ q \/ r /\ s
[@ ]
logic let  m3  : _ = fun p q r s -> p /\ q \/ r /\ s
[@ ]
logic let  m4  : _ = fun p q r s -> p /\ q \/ r /\ s
[@ ]
private let  uu___107  : _ = FStar.Pervasives.assert_norm (Bug1997.m1 == Bug1997.m2)
[@ ]
private let  uu___108  : _ = FStar.Pervasives.assert_norm (Bug1997.m1 == Bug1997.m3)
[@ ]
private let  uu___109  : _ = FStar.Pervasives.assert_norm (Bug1997.m1 == Bug1997.m4)
[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___110  : _ = FStar.Pervasives.assert_norm (Bug1997.m0 == Bug1997.m1)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___111  : _ = FStar.Pervasives.assert_norm (Bug1997.m0 == Bug1997.m2)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___112  : _ = FStar.Pervasives.assert_norm (Bug1997.m0 == Bug1997.m3)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___113  : _ = FStar.Pervasives.assert_norm (Bug1997.m0 == Bug1997.m4)
(* / Sig_fail*)

[@ ]
logic let  n0  : _ = fun p q r s -> p \/ q /\ r \/ s
[@ ]
logic let  n1  : _ = fun p q r s -> p \/ q /\ r \/ s
[@ ]
logic let  n2  : _ = fun p q r s -> (p \/ q) /\ r \/ s
[@ ]
logic let  n3  : _ = fun p q r s -> (p \/ q) /\ (r \/ s)
[@ ]
logic let  n4  : _ = fun p q r s -> p \/ q /\ (r \/ s)
[@ ]
private let  uu___134  : _ = FStar.Pervasives.assert_norm (Bug1997.n0 == Bug1997.n1)
[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___135  : _ = FStar.Pervasives.assert_norm (Bug1997.n1 == Bug1997.n2)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___136  : _ = FStar.Pervasives.assert_norm (Bug1997.n1 == Bug1997.n3)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___137  : _ = FStar.Pervasives.assert_norm (Bug1997.n1 == Bug1997.n4)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___138  : _ = FStar.Pervasives.assert_norm (Bug1997.n2 == Bug1997.n3)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___139  : _ = FStar.Pervasives.assert_norm (Bug1997.n2 == Bug1997.n4)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___140  : _ = FStar.Pervasives.assert_norm (Bug1997.n3 == Bug1997.n4)
(* / Sig_fail*)

]

Module before type checking:
module Bug1997
Declarations: [
[@ ]
let  op_Equals_Hat  : _ = fun a b -> a + b
[@ ]
let  test1  : _ = fun a b c -> a =^ b =^ c
[@ ]
let  test2  : _ = fun a b c -> a =^ b =^ c
[@ ]
let  test3  : _ = fun a b c -> a =^ (b =^ c)
[@ ]
private let  uu___11  : _ = FStar.Pervasives.assert_norm (Bug1997.test1 == Bug1997.test2)
[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___12  : _ = FStar.Pervasives.assert_norm (Bug1997.test1 == Bug1997.test3)
(* / Sig_fail*)

[@ ]
logic let  imp_assoc_0  : _ = fun p q r -> p ==> q ==> r
[@ ]
logic let  imp_assoc_1  : _ = fun p q r -> p ==> q ==> r
[@ ]
logic let  imp_assoc_2  : _ = fun p q r -> (p ==> q) ==> r
[@ ]
private let  uu___22  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_assoc_0 == Bug1997.imp_assoc_1)
[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___23  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_assoc_1 == Bug1997.imp_assoc_2)
(* / Sig_fail*)

[@ ]
logic let  imp_iff_0  : _ = fun p q r -> p ==> q <==> r
[@ ]
logic let  imp_iff_1  : _ = fun p q r -> p ==> q <==> r
[@ ]
logic let  imp_iff_2  : _ = fun p q r -> p ==> (q <==> r)
[@ ]
private let  uu___33  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_iff_0 == Bug1997.imp_iff_1)
[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___34  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_iff_1 == Bug1997.imp_iff_2)
(* / Sig_fail*)

[@ ]
logic let  imp_conj_1  : _ = fun p q r s -> p ==> q /\ r ==> s
[@ ]
logic let  imp_conj_2  : _ = fun p q r s -> (p ==> q) /\ (r ==> s)
[@ ]
logic let  imp_conj_3  : _ = fun p q r s -> p ==> q /\ (r ==> s)
[@ ]
logic let  imp_conj_4  : _ = fun p q r s -> p ==> q /\ r ==> s
[@ ]
private let  uu___51  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_conj_1 == Bug1997.imp_conj_4)
[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___52  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_conj_1 == Bug1997.imp_conj_3)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___53  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_conj_1 == Bug1997.imp_conj_2)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___54  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_conj_2 == Bug1997.imp_conj_3)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___55  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_conj_2 == Bug1997.imp_conj_4)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___56  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_conj_3 == Bug1997.imp_conj_4)
(* / Sig_fail*)

[@ ]
logic let  impneg1  : _ = fun p q r -> p ==> q /\ ~p ==> r
[@ ]
logic let  impneg2  : _ = fun p q r -> (p ==> q) /\ (~p ==> r)
[@ ]
logic let  impneg3  : _ = fun p q r -> p ==> q /\ (~p ==> r)
[@ ]
logic let  impneg4  : _ = fun p q r -> p ==> q /\ ~p ==> r
[@ ]
private let  uu___69  : _ = FStar.Pervasives.assert_norm (Bug1997.impneg1 == Bug1997.impneg4)
[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___70  : _ = FStar.Pervasives.assert_norm (Bug1997.impneg1 == Bug1997.impneg3)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___71  : _ = FStar.Pervasives.assert_norm (Bug1997.impneg1 == Bug1997.impneg2)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___72  : _ = FStar.Pervasives.assert_norm (Bug1997.impneg2 == Bug1997.impneg3)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___73  : _ = FStar.Pervasives.assert_norm (Bug1997.impneg2 == Bug1997.impneg4)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___74  : _ = FStar.Pervasives.assert_norm (Bug1997.impneg3 == Bug1997.impneg4)
(* / Sig_fail*)

[@ ]
logic let  cd1  : _ = fun p q r -> p /\ q \/ r
[@ ]
logic let  cd2  : _ = fun p q r -> p /\ q \/ r
[@ ]
logic let  cd3  : _ = fun p q r -> p /\ (q \/ r)
[@ ]
private let  uu___84  : _ = FStar.Pervasives.assert_norm (Bug1997.cd1 == Bug1997.cd2)
[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___85  : _ = FStar.Pervasives.assert_norm (Bug1997.cd1 == Bug1997.cd3)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___86  : _ = FStar.Pervasives.assert_norm (Bug1997.cd2 == Bug1997.cd3)
(* / Sig_fail*)

[@ ]
logic let  m0  : _ = fun p q r s -> p /\ (q \/ r) /\ s
[@ ]
logic let  m1  : _ = fun p q r s -> p /\ q \/ r /\ s
[@ ]
logic let  m2  : _ = fun p q r s -> p /\ q \/ r /\ s
[@ ]
logic let  m3  : _ = fun p q r s -> p /\ q \/ r /\ s
[@ ]
logic let  m4  : _ = fun p q r s -> p /\ q \/ r /\ s
[@ ]
private let  uu___107  : _ = FStar.Pervasives.assert_norm (Bug1997.m1 == Bug1997.m2)
[@ ]
private let  uu___108  : _ = FStar.Pervasives.assert_norm (Bug1997.m1 == Bug1997.m3)
[@ ]
private let  uu___109  : _ = FStar.Pervasives.assert_norm (Bug1997.m1 == Bug1997.m4)
[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___110  : _ = FStar.Pervasives.assert_norm (Bug1997.m0 == Bug1997.m1)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___111  : _ = FStar.Pervasives.assert_norm (Bug1997.m0 == Bug1997.m2)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___112  : _ = FStar.Pervasives.assert_norm (Bug1997.m0 == Bug1997.m3)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___113  : _ = FStar.Pervasives.assert_norm (Bug1997.m0 == Bug1997.m4)
(* / Sig_fail*)

[@ ]
logic let  n0  : _ = fun p q r s -> p \/ q /\ r \/ s
[@ ]
logic let  n1  : _ = fun p q r s -> p \/ q /\ r \/ s
[@ ]
logic let  n2  : _ = fun p q r s -> (p \/ q) /\ r \/ s
[@ ]
logic let  n3  : _ = fun p q r s -> (p \/ q) /\ (r \/ s)
[@ ]
logic let  n4  : _ = fun p q r s -> p \/ q /\ (r \/ s)
[@ ]
private let  uu___134  : _ = FStar.Pervasives.assert_norm (Bug1997.n0 == Bug1997.n1)
[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___135  : _ = FStar.Pervasives.assert_norm (Bug1997.n1 == Bug1997.n2)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___136  : _ = FStar.Pervasives.assert_norm (Bug1997.n1 == Bug1997.n3)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___137  : _ = FStar.Pervasives.assert_norm (Bug1997.n1 == Bug1997.n4)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___138  : _ = FStar.Pervasives.assert_norm (Bug1997.n2 == Bug1997.n3)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___139  : _ = FStar.Pervasives.assert_norm (Bug1997.n2 == Bug1997.n4)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___140  : _ = FStar.Pervasives.assert_norm (Bug1997.n3 == Bug1997.n4)
(* / Sig_fail*)

]
Exports: [
[@ ]
let  op_Equals_Hat  : _ = fun a b -> a + b
[@ ]
let  test1  : _ = fun a b c -> a =^ b =^ c
[@ ]
let  test2  : _ = fun a b c -> a =^ b =^ c
[@ ]
let  test3  : _ = fun a b c -> a =^ (b =^ c)
[@ ]
private let  uu___11  : _ = FStar.Pervasives.assert_norm (Bug1997.test1 == Bug1997.test2)
[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___12  : _ = FStar.Pervasives.assert_norm (Bug1997.test1 == Bug1997.test3)
(* / Sig_fail*)

[@ ]
logic let  imp_assoc_0  : _ = fun p q r -> p ==> q ==> r
[@ ]
logic let  imp_assoc_1  : _ = fun p q r -> p ==> q ==> r
[@ ]
logic let  imp_assoc_2  : _ = fun p q r -> (p ==> q) ==> r
[@ ]
private let  uu___22  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_assoc_0 == Bug1997.imp_assoc_1)
[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___23  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_assoc_1 == Bug1997.imp_assoc_2)
(* / Sig_fail*)

[@ ]
logic let  imp_iff_0  : _ = fun p q r -> p ==> q <==> r
[@ ]
logic let  imp_iff_1  : _ = fun p q r -> p ==> q <==> r
[@ ]
logic let  imp_iff_2  : _ = fun p q r -> p ==> (q <==> r)
[@ ]
private let  uu___33  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_iff_0 == Bug1997.imp_iff_1)
[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___34  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_iff_1 == Bug1997.imp_iff_2)
(* / Sig_fail*)

[@ ]
logic let  imp_conj_1  : _ = fun p q r s -> p ==> q /\ r ==> s
[@ ]
logic let  imp_conj_2  : _ = fun p q r s -> (p ==> q) /\ (r ==> s)
[@ ]
logic let  imp_conj_3  : _ = fun p q r s -> p ==> q /\ (r ==> s)
[@ ]
logic let  imp_conj_4  : _ = fun p q r s -> p ==> q /\ r ==> s
[@ ]
private let  uu___51  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_conj_1 == Bug1997.imp_conj_4)
[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___52  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_conj_1 == Bug1997.imp_conj_3)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___53  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_conj_1 == Bug1997.imp_conj_2)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___54  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_conj_2 == Bug1997.imp_conj_3)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___55  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_conj_2 == Bug1997.imp_conj_4)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___56  : _ = FStar.Pervasives.assert_norm (Bug1997.imp_conj_3 == Bug1997.imp_conj_4)
(* / Sig_fail*)

[@ ]
logic let  impneg1  : _ = fun p q r -> p ==> q /\ ~p ==> r
[@ ]
logic let  impneg2  : _ = fun p q r -> (p ==> q) /\ (~p ==> r)
[@ ]
logic let  impneg3  : _ = fun p q r -> p ==> q /\ (~p ==> r)
[@ ]
logic let  impneg4  : _ = fun p q r -> p ==> q /\ ~p ==> r
[@ ]
private let  uu___69  : _ = FStar.Pervasives.assert_norm (Bug1997.impneg1 == Bug1997.impneg4)
[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___70  : _ = FStar.Pervasives.assert_norm (Bug1997.impneg1 == Bug1997.impneg3)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___71  : _ = FStar.Pervasives.assert_norm (Bug1997.impneg1 == Bug1997.impneg2)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___72  : _ = FStar.Pervasives.assert_norm (Bug1997.impneg2 == Bug1997.impneg3)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___73  : _ = FStar.Pervasives.assert_norm (Bug1997.impneg2 == Bug1997.impneg4)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___74  : _ = FStar.Pervasives.assert_norm (Bug1997.impneg3 == Bug1997.impneg4)
(* / Sig_fail*)

[@ ]
logic let  cd1  : _ = fun p q r -> p /\ q \/ r
[@ ]
logic let  cd2  : _ = fun p q r -> p /\ q \/ r
[@ ]
logic let  cd3  : _ = fun p q r -> p /\ (q \/ r)
[@ ]
private let  uu___84  : _ = FStar.Pervasives.assert_norm (Bug1997.cd1 == Bug1997.cd2)
[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___85  : _ = FStar.Pervasives.assert_norm (Bug1997.cd1 == Bug1997.cd3)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___86  : _ = FStar.Pervasives.assert_norm (Bug1997.cd2 == Bug1997.cd3)
(* / Sig_fail*)

[@ ]
logic let  m0  : _ = fun p q r s -> p /\ (q \/ r) /\ s
[@ ]
logic let  m1  : _ = fun p q r s -> p /\ q \/ r /\ s
[@ ]
logic let  m2  : _ = fun p q r s -> p /\ q \/ r /\ s
[@ ]
logic let  m3  : _ = fun p q r s -> p /\ q \/ r /\ s
[@ ]
logic let  m4  : _ = fun p q r s -> p /\ q \/ r /\ s
[@ ]
private let  uu___107  : _ = FStar.Pervasives.assert_norm (Bug1997.m1 == Bug1997.m2)
[@ ]
private let  uu___108  : _ = FStar.Pervasives.assert_norm (Bug1997.m1 == Bug1997.m3)
[@ ]
private let  uu___109  : _ = FStar.Pervasives.assert_norm (Bug1997.m1 == Bug1997.m4)
[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___110  : _ = FStar.Pervasives.assert_norm (Bug1997.m0 == Bug1997.m1)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___111  : _ = FStar.Pervasives.assert_norm (Bug1997.m0 == Bug1997.m2)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___112  : _ = FStar.Pervasives.assert_norm (Bug1997.m0 == Bug1997.m3)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___113  : _ = FStar.Pervasives.assert_norm (Bug1997.m0 == Bug1997.m4)
(* / Sig_fail*)

[@ ]
logic let  n0  : _ = fun p q r s -> p \/ q /\ r \/ s
[@ ]
logic let  n1  : _ = fun p q r s -> p \/ q /\ r \/ s
[@ ]
logic let  n2  : _ = fun p q r s -> (p \/ q) /\ r \/ s
[@ ]
logic let  n3  : _ = fun p q r s -> (p \/ q) /\ (r \/ s)
[@ ]
logic let  n4  : _ = fun p q r s -> p \/ q /\ (r \/ s)
[@ ]
private let  uu___134  : _ = FStar.Pervasives.assert_norm (Bug1997.n0 == Bug1997.n1)
[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___135  : _ = FStar.Pervasives.assert_norm (Bug1997.n1 == Bug1997.n2)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___136  : _ = FStar.Pervasives.assert_norm (Bug1997.n1 == Bug1997.n3)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___137  : _ = FStar.Pervasives.assert_norm (Bug1997.n1 == Bug1997.n4)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___138  : _ = FStar.Pervasives.assert_norm (Bug1997.n2 == Bug1997.n3)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___139  : _ = FStar.Pervasives.assert_norm (Bug1997.n2 == Bug1997.n4)
(* / Sig_fail*)

[@ (FStar.Pervasives.expect_failure)]
(* Sig_fail false [] *)
[@ ]
private let  uu___140  : _ = FStar.Pervasives.assert_norm (Bug1997.n3 == Bug1997.n4)
(* / Sig_fail*)

]

>> Got issues: [
Bug1997.fst(13,19-13,55): (Error 19) assertion failed (Also see: prims.fst(96,32-96,42)); The SMT solver could not prove the query, try to spell your proof in more detail or increase fuel/ifuel
>>]
>> Got issues: [
Bug1997.fst(21,19-21,67): (Error 19) assertion failed (Also see: prims.fst(96,32-96,42)); The SMT solver could not prove the query, try to spell your proof in more detail or increase fuel/ifuel
>>]
>> Got issues: [
Bug1997.fst(29,19-29,63): (Error 19) assertion failed (Also see: prims.fst(96,32-96,42)); The SMT solver could not prove the query, try to spell your proof in more detail or increase fuel/ifuel
>>]
>> Got issues: [
Bug1997.fst(38,19-38,65): (Error 19) assertion failed (Also see: prims.fst(96,32-96,42)); The SMT solver could not prove the query, try to spell your proof in more detail or increase fuel/ifuel
>>]
>> Got issues: [
Bug1997.fst(39,19-39,65): (Error 19) assertion failed (Also see: prims.fst(96,32-96,42)); The SMT solver could not prove the query, try to spell your proof in more detail or increase fuel/ifuel
>>]
>> Got issues: [
Bug1997.fst(40,19-40,65): (Error 19) assertion failed (Also see: prims.fst(96,32-96,42)); The SMT solver could not prove the query, try to spell your proof in more detail or increase fuel/ifuel
>>]
>> Got issues: [
Bug1997.fst(41,19-41,65): (Error 19) assertion failed (Also see: prims.fst(96,32-96,42)); The SMT solver could not prove the query, try to spell your proof in more detail or increase fuel/ifuel
>>]
>> Got issues: [
Bug1997.fst(42,19-42,65): (Error 19) assertion failed (Also see: prims.fst(96,32-96,42)); The SMT solver could not prove the query, try to spell your proof in more detail or increase fuel/ifuel
>>]
>> Got issues: [
Bug1997.fst(51,19-51,59): (Error 19) assertion failed (Also see: prims.fst(96,32-96,42)); The SMT solver could not prove the query, try to spell your proof in more detail or increase fuel/ifuel
>>]
>> Got issues: [
Bug1997.fst(52,19-52,59): (Error 19) assertion failed (Also see: prims.fst(96,32-96,42)); The SMT solver could not prove the query, try to spell your proof in more detail or increase fuel/ifuel
>>]
>> Got issues: [
Bug1997.fst(53,19-53,59): (Error 19) assertion failed (Also see: prims.fst(96,32-96,42)); The SMT solver could not prove the query, try to spell your proof in more detail or increase fuel/ifuel
>>]
>> Got issues: [
Bug1997.fst(54,19-54,59): (Error 19) assertion failed (Also see: prims.fst(96,32-96,42)); The SMT solver could not prove the query, try to spell your proof in more detail or increase fuel/ifuel
>>]
>> Got issues: [
Bug1997.fst(55,19-55,59): (Error 19) assertion failed (Also see: prims.fst(96,32-96,42)); The SMT solver could not prove the query, try to spell your proof in more detail or increase fuel/ifuel
>>]
>> Got issues: [
Bug1997.fst(63,19-63,51): (Error 19) assertion failed (Also see: prims.fst(96,32-96,42)); The SMT solver could not prove the query, try to spell your proof in more detail or increase fuel/ifuel
>>]
>> Got issues: [
Bug1997.fst(64,19-64,51): (Error 19) assertion failed (Also see: prims.fst(96,32-96,42)); The SMT solver could not prove the query, try to spell your proof in more detail or increase fuel/ifuel
>>]
>> Got issues: [
Bug1997.fst(75,19-75,49): (Error 19) assertion failed (Also see: prims.fst(96,32-96,42)); The SMT solver could not prove the query, try to spell your proof in more detail or increase fuel/ifuel
>>]
>> Got issues: [
Bug1997.fst(76,19-76,49): (Error 19) assertion failed (Also see: prims.fst(96,32-96,42)); The SMT solver could not prove the query, try to spell your proof in more detail or increase fuel/ifuel
>>]
>> Got issues: [
Bug1997.fst(77,19-77,49): (Error 19) assertion failed (Also see: prims.fst(96,32-96,42)); The SMT solver could not prove the query, try to spell your proof in more detail or increase fuel/ifuel
>>]
>> Got issues: [
Bug1997.fst(78,19-78,49): (Error 19) assertion failed (Also see: prims.fst(96,32-96,42)); The SMT solver could not prove the query, try to spell your proof in more detail or increase fuel/ifuel
>>]
>> Got issues: [
Bug1997.fst(87,19-87,49): (Error 19) assertion failed (Also see: prims.fst(96,32-96,42)); The SMT solver could not prove the query, try to spell your proof in more detail or increase fuel/ifuel
>>]
>> Got issues: [
Bug1997.fst(88,19-88,49): (Error 19) assertion failed (Also see: prims.fst(96,32-96,42)); The SMT solver could not prove the query, try to spell your proof in more detail or increase fuel/ifuel
>>]
>> Got issues: [
Bug1997.fst(89,19-89,49): (Error 19) assertion failed (Also see: prims.fst(96,32-96,42)); The SMT solver could not prove the query, try to spell your proof in more detail or increase fuel/ifuel
>>]
>> Got issues: [
Bug1997.fst(90,19-90,49): (Error 19) assertion failed (Also see: prims.fst(96,32-96,42)); The SMT solver could not prove the query, try to spell your proof in more detail or increase fuel/ifuel
>>]
>> Got issues: [
Bug1997.fst(91,19-91,49): (Error 19) assertion failed (Also see: prims.fst(96,32-96,42)); The SMT solver could not prove the query, try to spell your proof in more detail or increase fuel/ifuel
>>]
>> Got issues: [
Bug1997.fst(92,19-92,49): (Error 19) assertion failed (Also see: prims.fst(96,32-96,42)); The SMT solver could not prove the query, try to spell your proof in more detail or increase fuel/ifuel
>>]
Module after type checking:
module Bug1997
Declarations: [
[@ ]
visible let  op_Equals_Hat  : a: Prims.int -> b: Prims.int -> Prims.Tot Prims.int = fun a b -> a + b
[@ ]
visible let  test1  : a: Prims.int -> b: Prims.int -> c: Prims.int -> Prims.Tot Prims.int = fun a b c -> a =^ b =^ c
[@ ]
visible let  test2  : a: Prims.int -> b: Prims.int -> c: Prims.int -> Prims.Tot Prims.int = fun a b c -> a =^ b =^ c
[@ ]
visible let  test3  : a: Prims.int -> b: Prims.int -> c: Prims.int -> Prims.Tot Prims.int = fun a b c -> a =^ (b =^ c)
[@ ]
visible private let  uu___11  : Prims.unit = FStar.Pervasives.assert_norm (Bug1997.test1 == Bug1997.test2)
[@ ]
visible logic let  imp_assoc_0  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> Prims.Tot Prims.logical = fun p q r -> p ==> q ==> r
[@ ]
visible logic let  imp_assoc_1  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> Prims.Tot Prims.logical = fun p q r -> p ==> q ==> r
[@ ]
visible logic let  imp_assoc_2  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> Prims.Tot Prims.logical = fun p q r -> (p ==> q) ==> r
[@ ]
visible private let  uu___22  : Prims.unit = FStar.Pervasives.assert_norm (Bug1997.imp_assoc_0 == Bug1997.imp_assoc_1)
[@ ]
visible logic let  imp_iff_0  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> Prims.Tot Prims.logical = fun p q r -> p ==> q <==> r
[@ ]
visible logic let  imp_iff_1  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> Prims.Tot Prims.logical = fun p q r -> p ==> q <==> r
[@ ]
visible logic let  imp_iff_2  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> Prims.Tot Prims.logical = fun p q r -> p ==> (q <==> r)
[@ ]
visible private let  uu___33  : Prims.unit = FStar.Pervasives.assert_norm (Bug1997.imp_iff_0 == Bug1997.imp_iff_1)
[@ ]
visible logic let  imp_conj_1  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> s: Prims.prop -> Prims.Tot Prims.logical = fun p q r s -> p ==> q /\ r ==> s
[@ ]
visible logic let  imp_conj_2  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> s: Prims.prop -> Prims.Tot Prims.logical = fun p q r s -> (p ==> q) /\ (r ==> s)
[@ ]
visible logic let  imp_conj_3  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> s: Prims.prop -> Prims.Tot Prims.logical = fun p q r s -> p ==> q /\ (r ==> s)
[@ ]
visible logic let  imp_conj_4  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> s: Prims.prop -> Prims.Tot Prims.logical = fun p q r s -> p ==> q /\ r ==> s
[@ ]
visible private let  uu___51  : Prims.unit = FStar.Pervasives.assert_norm (Bug1997.imp_conj_1 == Bug1997.imp_conj_4)
[@ ]
visible logic let  impneg1  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> Prims.Tot Prims.logical = fun p q r -> p ==> q /\ ~p ==> r
[@ ]
visible logic let  impneg2  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> Prims.Tot Prims.logical = fun p q r -> (p ==> q) /\ (~p ==> r)
[@ ]
visible logic let  impneg3  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> Prims.Tot Prims.logical = fun p q r -> p ==> q /\ (~p ==> r)
[@ ]
visible logic let  impneg4  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> Prims.Tot Prims.logical = fun p q r -> p ==> q /\ ~p ==> r
[@ ]
visible private let  uu___69  : Prims.unit = FStar.Pervasives.assert_norm (Bug1997.impneg1 == Bug1997.impneg4)
[@ ]
visible logic let  cd1  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> Prims.Tot Prims.logical = fun p q r -> p /\ q \/ r
[@ ]
visible logic let  cd2  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> Prims.Tot Prims.logical = fun p q r -> p /\ q \/ r
[@ ]
visible logic let  cd3  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> Prims.Tot Prims.logical = fun p q r -> p /\ (q \/ r)
[@ ]
visible private let  uu___84  : Prims.unit = FStar.Pervasives.assert_norm (Bug1997.cd1 == Bug1997.cd2)
[@ ]
visible logic let  m0  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> s: Prims.prop -> Prims.Tot Prims.logical = fun p q r s -> p /\ (q \/ r) /\ s
[@ ]
visible logic let  m1  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> s: Prims.prop -> Prims.Tot Prims.logical = fun p q r s -> p /\ q \/ r /\ s
[@ ]
visible logic let  m2  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> s: Prims.prop -> Prims.Tot Prims.logical = fun p q r s -> p /\ q \/ r /\ s
[@ ]
visible logic let  m3  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> s: Prims.prop -> Prims.Tot Prims.logical = fun p q r s -> p /\ q \/ r /\ s
[@ ]
visible logic let  m4  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> s: Prims.prop -> Prims.Tot Prims.logical = fun p q r s -> p /\ q \/ r /\ s
[@ ]
visible private let  uu___107  : Prims.unit = FStar.Pervasives.assert_norm (Bug1997.m1 == Bug1997.m2)
[@ ]
visible private let  uu___108  : Prims.unit = FStar.Pervasives.assert_norm (Bug1997.m1 == Bug1997.m3)
[@ ]
visible private let  uu___109  : Prims.unit = FStar.Pervasives.assert_norm (Bug1997.m1 == Bug1997.m4)
[@ ]
visible logic let  n0  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> s: Prims.prop -> Prims.Tot Prims.logical = fun p q r s -> p \/ q /\ r \/ s
[@ ]
visible logic let  n1  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> s: Prims.prop -> Prims.Tot Prims.logical = fun p q r s -> p \/ q /\ r \/ s
[@ ]
visible logic let  n2  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> s: Prims.prop -> Prims.Tot Prims.logical = fun p q r s -> (p \/ q) /\ r \/ s
[@ ]
visible logic let  n3  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> s: Prims.prop -> Prims.Tot Prims.logical = fun p q r s -> (p \/ q) /\ (r \/ s)
[@ ]
visible logic let  n4  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> s: Prims.prop -> Prims.Tot Prims.logical = fun p q r s -> p \/ q /\ (r \/ s)
[@ ]
visible private let  uu___134  : Prims.unit = FStar.Pervasives.assert_norm (Bug1997.n0 == Bug1997.n1)
]
Exports: [
[@ ]
visible let  op_Equals_Hat  : a: Prims.int -> b: Prims.int -> Prims.Tot Prims.int = fun a b -> a + b
[@ ]
visible let  test1  : a: Prims.int -> b: Prims.int -> c: Prims.int -> Prims.Tot Prims.int = fun a b c -> a =^ b =^ c
[@ ]
visible let  test2  : a: Prims.int -> b: Prims.int -> c: Prims.int -> Prims.Tot Prims.int = fun a b c -> a =^ b =^ c
[@ ]
visible let  test3  : a: Prims.int -> b: Prims.int -> c: Prims.int -> Prims.Tot Prims.int = fun a b c -> a =^ (b =^ c)
[@ ]
visible private let  uu___11  : Prims.unit = FStar.Pervasives.assert_norm (Bug1997.test1 == Bug1997.test2)
[@ ]
visible logic let  imp_assoc_0  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> Prims.Tot Prims.logical = fun p q r -> p ==> q ==> r
[@ ]
visible logic let  imp_assoc_1  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> Prims.Tot Prims.logical = fun p q r -> p ==> q ==> r
[@ ]
visible logic let  imp_assoc_2  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> Prims.Tot Prims.logical = fun p q r -> (p ==> q) ==> r
[@ ]
visible private let  uu___22  : Prims.unit = FStar.Pervasives.assert_norm (Bug1997.imp_assoc_0 == Bug1997.imp_assoc_1)
[@ ]
visible logic let  imp_iff_0  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> Prims.Tot Prims.logical = fun p q r -> p ==> q <==> r
[@ ]
visible logic let  imp_iff_1  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> Prims.Tot Prims.logical = fun p q r -> p ==> q <==> r
[@ ]
visible logic let  imp_iff_2  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> Prims.Tot Prims.logical = fun p q r -> p ==> (q <==> r)
[@ ]
visible private let  uu___33  : Prims.unit = FStar.Pervasives.assert_norm (Bug1997.imp_iff_0 == Bug1997.imp_iff_1)
[@ ]
visible logic let  imp_conj_1  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> s: Prims.prop -> Prims.Tot Prims.logical = fun p q r s -> p ==> q /\ r ==> s
[@ ]
visible logic let  imp_conj_2  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> s: Prims.prop -> Prims.Tot Prims.logical = fun p q r s -> (p ==> q) /\ (r ==> s)
[@ ]
visible logic let  imp_conj_3  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> s: Prims.prop -> Prims.Tot Prims.logical = fun p q r s -> p ==> q /\ (r ==> s)
[@ ]
visible logic let  imp_conj_4  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> s: Prims.prop -> Prims.Tot Prims.logical = fun p q r s -> p ==> q /\ r ==> s
[@ ]
visible private let  uu___51  : Prims.unit = FStar.Pervasives.assert_norm (Bug1997.imp_conj_1 == Bug1997.imp_conj_4)
[@ ]
visible logic let  impneg1  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> Prims.Tot Prims.logical = fun p q r -> p ==> q /\ ~p ==> r
[@ ]
visible logic let  impneg2  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> Prims.Tot Prims.logical = fun p q r -> (p ==> q) /\ (~p ==> r)
[@ ]
visible logic let  impneg3  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> Prims.Tot Prims.logical = fun p q r -> p ==> q /\ (~p ==> r)
[@ ]
visible logic let  impneg4  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> Prims.Tot Prims.logical = fun p q r -> p ==> q /\ ~p ==> r
[@ ]
visible private let  uu___69  : Prims.unit = FStar.Pervasives.assert_norm (Bug1997.impneg1 == Bug1997.impneg4)
[@ ]
visible logic let  cd1  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> Prims.Tot Prims.logical = fun p q r -> p /\ q \/ r
[@ ]
visible logic let  cd2  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> Prims.Tot Prims.logical = fun p q r -> p /\ q \/ r
[@ ]
visible logic let  cd3  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> Prims.Tot Prims.logical = fun p q r -> p /\ (q \/ r)
[@ ]
visible private let  uu___84  : Prims.unit = FStar.Pervasives.assert_norm (Bug1997.cd1 == Bug1997.cd2)
[@ ]
visible logic let  m0  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> s: Prims.prop -> Prims.Tot Prims.logical = fun p q r s -> p /\ (q \/ r) /\ s
[@ ]
visible logic let  m1  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> s: Prims.prop -> Prims.Tot Prims.logical = fun p q r s -> p /\ q \/ r /\ s
[@ ]
visible logic let  m2  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> s: Prims.prop -> Prims.Tot Prims.logical = fun p q r s -> p /\ q \/ r /\ s
[@ ]
visible logic let  m3  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> s: Prims.prop -> Prims.Tot Prims.logical = fun p q r s -> p /\ q \/ r /\ s
[@ ]
visible logic let  m4  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> s: Prims.prop -> Prims.Tot Prims.logical = fun p q r s -> p /\ q \/ r /\ s
[@ ]
visible private let  uu___107  : Prims.unit = FStar.Pervasives.assert_norm (Bug1997.m1 == Bug1997.m2)
[@ ]
visible private let  uu___108  : Prims.unit = FStar.Pervasives.assert_norm (Bug1997.m1 == Bug1997.m3)
[@ ]
visible private let  uu___109  : Prims.unit = FStar.Pervasives.assert_norm (Bug1997.m1 == Bug1997.m4)
[@ ]
visible logic let  n0  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> s: Prims.prop -> Prims.Tot Prims.logical = fun p q r s -> p \/ q /\ r \/ s
[@ ]
visible logic let  n1  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> s: Prims.prop -> Prims.Tot Prims.logical = fun p q r s -> p \/ q /\ r \/ s
[@ ]
visible logic let  n2  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> s: Prims.prop -> Prims.Tot Prims.logical = fun p q r s -> (p \/ q) /\ r \/ s
[@ ]
visible logic let  n3  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> s: Prims.prop -> Prims.Tot Prims.logical = fun p q r s -> (p \/ q) /\ (r \/ s)
[@ ]
visible logic let  n4  : p: Prims.prop -> q: Prims.prop -> r: Prims.prop -> s: Prims.prop -> Prims.Tot Prims.logical = fun p q r s -> p \/ q /\ (r \/ s)
[@ ]
visible private let  uu___134  : Prims.unit = FStar.Pervasives.assert_norm (Bug1997.n0 == Bug1997.n1)
]

Verified module: Bug1997
All verification conditions discharged successfully
